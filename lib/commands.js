const config = require('../config');
const { c2i, yts, cineInfo, cineDl, aiChat } = require('./api');

async function handleCommand(sock, from, command, text, m, sender) {
    
    switch (command) {
        case "menu":
        case "help":
            await sock.sendMessage(from, {
                image: { url: config.botImage },
                caption: `
*üë∏ QUEEN SELINA BOT V3*
_Created by ${config.ownerName}_

*üîç AI & SEARCH*
‚Ä¢ ${config.prefix}ai <query> (Chat with Bot)
‚Ä¢ ${config.prefix}yts <song name> (YouTube Search)
‚Ä¢ ${config.prefix}c2i <color/text> (Generate Image)

*üé• MOVIES (Cinesubz)*
‚Ä¢ ${config.prefix}movie <url> (Get Info)
‚Ä¢ ${config.prefix}moviedl <url> (Get Download Link)

*‚öôÔ∏è SYSTEM*
‚Ä¢ ${config.prefix}ping (Check Speed)
‚Ä¢ ${config.prefix}owner (Dev Contact)
‚Ä¢ ${config.prefix}id (Get Chat ID)

_Powering ${config.maxBots} Bots 24/7_
`
            });
            break;

        case "ping":
            const start = Date.now();
            await sock.sendMessage(from, { text: "Testing speed..." });
            const lat = Date.now() - start;
            await sock.sendMessage(from, { text: `*Pong!* üèì\nLatency: ${lat}ms` });
            break;

        case "owner":
            await sock.sendMessage(from, { 
                contacts: { displayName: config.ownerName, contacts: [{ vcard: `BEGIN:VCARD\nVERSION:3.0\nFN:${config.ownerName}\nTEL;type=CELL;type=VOICE;waid=${config.ownerNumber}:${config.ownerNumber}\nEND:VCARD` }] }
            });
            break;

        case "ai":
        case "gpt":
            if (!text) return sock.sendMessage(from, { text: "Please type a question!" });
            const reply = await aiChat(text);
            await sock.sendMessage(from, { text: reply });
            break;

        case "c2i":
            if (!text) return sock.sendMessage(from, { text: "Give me a color or text!" });
            const img = await c2i(text);
            if (img) await sock.sendMessage(from, { image: img, caption: "üé® Generated by Queen Selina" });
            else await sock.sendMessage(from, { text: "Error generating image." });
            break;

        case "yts":
            if (!text) return sock.sendMessage(from, { text: "Enter a song name!" });
            const ytsData = await yts(text);
            await sock.sendMessage(from, { text: `*YouTube Search:*\n\n${JSON.stringify(ytsData, null, 2)}` });
            break;

        case "movie":
            if (!text) return sock.sendMessage(from, { text: "Enter a Cinesubz URL!" });
            const mData = await cineInfo(text);
            await sock.sendMessage(from, { text: `*üé¨ Movie Info:*\n\n${JSON.stringify(mData, null, 2)}` });
            break;

        case "moviedl":
            if (!text) return sock.sendMessage(from, { text: "Enter a Cinesubz URL!" });
            const dlData = await cineDl(text);
            await sock.sendMessage(from, { text: `*‚¨áÔ∏è Download Links:*\n\n${JSON.stringify(dlData, null, 2)}` });
            break;

        case "broadcast":
            // Check if sender is owner
            if (!sender.includes(config.ownerNumber)) return;
            const groups = await sock.groupFetchAllParticipating();
            const gIds = Object.keys(groups);
            await sock.sendMessage(from, { text: `Sending to ${gIds.length} groups...` });
            for (let id of gIds) {
                await sock.sendMessage(id, { text: `*üì¢ System Broadcast:*\n\n${text}` });
                // Small delay to prevent ban
                await new Promise(r => setTimeout(r, 1000));
            }
            break;
    }
}

module.exports = { handleCommand };
